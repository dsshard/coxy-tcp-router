{"version":3,"sources":["../src/utils/encryptor.ts","../src/interface.ts","../src/utils/defer.ts","../src/utils/pipeline.ts","../src/server.ts","../src/client.ts"],"names":["ALG","IV_LEN","TAG_LEN","toKey","hex","crypto","encrypt","data","keyHex","key","iv","cipher","enc","tag","decrypt","payload","raw","decipher","BaseInterface","EventEmitter","sock","createDefer","resolve","reject","promise","_resolve","_reject","Pipeline","mw","stack","m","ctx","i","runner","idx","fn","TcpServer","o","createServer","s","cb","defer","ip","shared","ecdh","first","msg","init","chunk","len","req","route","pipe","res","body","e","out","buf","frame","r","p","TcpClient","opt","Socket","err","str","resp","rec","rout","uuid","packet"],"mappings":"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","file":"index.js","sourcesContent":["import crypto from 'crypto'\nconst ALG = 'aes-256-gcm'\nconst IV_LEN = 12\nconst TAG_LEN = 16\n\nfunction toKey(hex: string) {\n  return crypto.createHash('sha256').update(hex).digest()\n}\n\nexport function encrypt(data: string, keyHex: string): string {\n  const key = toKey(keyHex)\n  const iv = crypto.randomBytes(IV_LEN)\n  const cipher = crypto.createCipheriv(ALG, key, iv)\n  const enc = Buffer.concat([cipher.update(data, 'utf8'), cipher.final()])\n  const tag = cipher.getAuthTag()\n  return Buffer.concat([iv, enc, tag]).toString('base64')\n}\nexport function decrypt(payload: string, keyHex: string): string {\n  const raw = Buffer.from(payload, 'base64')\n  const key = toKey(keyHex)\n  const iv = raw.subarray(0, IV_LEN)\n  const tag = raw.subarray(raw.length - TAG_LEN)\n  const enc = raw.subarray(IV_LEN, raw.length - TAG_LEN)\n  const decipher = crypto.createDecipheriv(ALG, key, iv)\n  decipher.setAuthTag(tag)\n  return Buffer.concat([decipher.update(enc), decipher.final()]).toString('utf8')\n}\n","import EventEmitter from 'events'\n\nimport { encrypt, decrypt } from './utils/encryptor'\n\nexport abstract class BaseInterface extends EventEmitter {\n  protected abstract getSecret(sock?: unknown): string\n  protected encrypt(data: string, sock?: unknown) {\n    if (!this.getSecret(sock)) {\n      return data\n    }\n    return encrypt(data, this.getSecret(sock))\n  }\n\n  protected decrypt<T = unknown>(payload: string, sock?: unknown): T {\n    if (!this.getSecret(sock)) {\n      return JSON.parse(payload)\n    }\n    return JSON.parse(decrypt(payload, this.getSecret(sock))) as T\n  }\n}\n","export function createDefer<T>() {\n  let resolve!: (value: T | PromiseLike<T>) => void\n  let reject!: (reason?: unknown) => void\n\n  const promise = new Promise<T>((_resolve, _reject) => {\n    resolve = _resolve\n    reject = _reject\n  })\n\n  return Object.assign(promise, { resolve, reject })\n}\n","export type Next = () => Promise<void> | void\nexport interface Context<TReq, TRes> {\n  request: TReq\n  rout: string\n  body?: TRes\n}\nexport type Middleware<T> = (ctx: T, next: Next) => Promise<void> | void\nexport interface Pipeline<TC, TR> {\n  push: (...mw: Middleware<TC>[]) => void\n  execute: (ctx: TC) => Promise<{ body: TR }>\n}\nexport function Pipeline<TC, TR>(...mw: Middleware<TC>[]): Pipeline<TC, TR> {\n  const stack: Middleware<TC>[] = [...mw]\n  const push = (...m: Middleware<TC>[]) => stack.push(...m)\n  const execute = async (ctx: TC) => {\n    let i = -1\n    const runner = async (idx: number): Promise<void> => {\n      if (idx === i) throw new Error('next() called multiple times')\n      i = idx\n      const fn = stack[idx]\n      if (fn) await fn(ctx, () => runner(idx + 1))\n    }\n    await runner(0)\n    if ((ctx as any).body === undefined) throw new Error('Pipeline did not set ctx.body')\n    return { body: (ctx as any).body as TR }\n  }\n  return { push, execute }\n}\n","import crypto from 'crypto'\nimport { createServer, Server, Socket } from 'net'\n\nimport { BaseInterface } from './interface'\nimport { createDefer } from './utils/defer'\nimport { Context, Middleware, Pipeline } from './utils/pipeline'\n\nexport interface TcpRouterOptions {\n  port: number\n  host?: string\n  secret?: string\n  whitelist?: readonly string[]\n  maxConnections?: number\n}\nexport interface HandshakeInitialBody {\n  pub: string\n  name?: string\n}\nexport interface RequestBody<T = unknown> {\n  uuid: string\n  body: T\n  rout: string\n}\nexport interface ResponseBody<T = unknown> {\n  uuid: string\n  body?: T\n  error?: string\n}\n\ndeclare module 'net' {\n  interface Socket {\n    secret?: string\n    clientName?: string\n    _buf?: Buffer\n  }\n}\n\ntype AnyPipe = Pipeline<Context<unknown, unknown>, unknown>\n\nexport class TcpServer extends BaseInterface {\n  private readonly server: Server\n  private readonly opts: TcpRouterOptions\n  private readonly routers = new Map<string, AnyPipe>()\n  private readonly active = new Set<Socket>()\n\n  constructor(o: TcpRouterOptions) {\n    super()\n    this.opts = o\n    this.server = createServer((s) => this.handleSocket(s))\n  }\n\n  listen(cb?: () => void) {\n    const defer = createDefer<void>()\n    this.server.listen(this.opts.port, this.opts.host, () => {\n      this.emit('listening')\n      defer.resolve()\n      if (cb) cb()\n    })\n\n    return defer\n  }\n\n  protected getSecret(s?: Socket) {\n    return `${this.opts.secret}${s?.secret ?? ''}`\n  }\n\n  // ---------------- socket lifecycle ----------------\n  private handleSocket(s: Socket) {\n    const ip = (s.remoteAddress ?? '').replace(/^::ffff:/, '')\n    if (this.opts.whitelist && !this.opts.whitelist.includes(ip)) {\n      this.emit('error:whitelist', s)\n      return s.destroy()\n    }\n    if (this.opts.maxConnections && this.active.size >= this.opts.maxConnections) {\n      this.emit('error:maxConnections', s)\n      return s.destroy()\n    }\n\n    this.active.add(s)\n    s.setKeepAlive(true)\n    s._buf = Buffer.alloc(0)\n    s.on('close', () => {\n      this.active.delete(s)\n      this.emit('close', s)\n      s.removeAllListeners()\n    })\n    this.handshake(s)\n  }\n\n  /** Gracefully stop listening and destroy all active sockets */\n  public close() {\n    const defer = createDefer<void>()\n    this.server.once('close', () => {\n      setTimeout(defer.resolve)\n    })\n    this.server.close()\n\n    for (const sock of this.active) {\n      sock.destroy()\n    }\n    return defer\n  }\n\n  private deriveKey(shared: Buffer) {\n    return crypto\n      .createHmac('sha256', this.opts.secret || '')\n      .update(shared)\n      .digest('hex')\n  }\n\n  // ---------------- handshake ----------------\n  private handshake(s: Socket) {\n    const ecdh = crypto.createECDH('prime256v1')\n    ecdh.generateKeys()\n    const first = (raw: Buffer) => {\n      s.off('data', first)\n      const msg = raw.toString().trimEnd()\n      let init: HandshakeInitialBody\n      try {\n        init = JSON.parse(msg)\n      } catch {\n        return s.destroy()\n      }\n      const shared = ecdh.computeSecret(Buffer.from(init.pub, 'hex'))\n      s.secret = this.deriveKey(shared)\n      s.clientName = init.name\n      s.write(`${JSON.stringify({ pub: ecdh.getPublicKey('hex') })}\\n`)\n      this.emit('connect', s, init.name)\n      s.on('data', (chunk) => this.readFrames(s, chunk))\n    }\n    s.on('data', first)\n  }\n\n  // ---------------- length‑prefix framed stream ----------------\n  private readFrames(s: Socket, chunk: Buffer) {\n    s._buf = Buffer.concat([s._buf!, chunk])\n    while (s._buf.length >= 4) {\n      const len = s._buf.readUInt32BE(0)\n      if (s._buf.length < 4 + len) break\n      const payload = s._buf.subarray(4, 4 + len).toString('utf8')\n      s._buf = s._buf.subarray(4 + len)\n      void this.handleData(payload, s)\n    }\n  }\n\n  private async handleData<Q = unknown, S = unknown>(cipher: string, s: Socket) {\n    let req: RequestBody<Q>\n    try {\n      req = this.decrypt<RequestBody<Q>>(cipher, s)\n    } catch {\n      return\n    }\n    const route = req.rout?.toLowerCase()\n    const pipe = this.routers.get(route) as Pipeline<Context<Q, S>, S> | undefined\n\n    const res: ResponseBody<S> = { uuid: req.uuid }\n    try {\n      if (!pipe) throw new Error(`Route ${route} not found`)\n      const { body } = await pipe.execute({ request: req.body, rout: route })\n      res.body = body\n    } catch (e) {\n      res.error = (e as Error).message\n    }\n\n    const out = this.encrypt(JSON.stringify(res), s)\n    const buf = Buffer.from(out, 'utf8')\n    const frame = Buffer.allocUnsafe(4 + buf.length)\n    frame.writeUInt32BE(buf.length, 0)\n    buf.copy(frame, 4)\n    s.write(frame)\n  }\n\n  // ------------- public -------------\n  public use<Q = unknown, S = unknown>(r: string, ...mw: Middleware<Context<Q, S>>[]) {\n    const p = Pipeline<Context<Q, S>, S>()\n    p.push(...mw)\n    this.routers.set(r.trim().toLowerCase(), p as AnyPipe)\n  }\n}\n","import crypto from 'crypto'\nimport { Socket } from 'net'\n\nimport { BaseInterface } from './interface'\nimport { HandshakeInitialBody, RequestBody, ResponseBody } from './server'\nimport { createDefer } from './utils/defer'\n\nexport interface TcpClientOptions {\n  port: number\n  host?: string\n  secret?: string\n  name?: string\n  autoReconnect?: boolean\n  timeoutReconnect?: number\n  requestTimeout?: number\n  maxPending?: number\n}\n\ntype Pending<T> = { ts: number; defer: ReturnType<typeof createDefer<T>> }\n\nexport class TcpClient extends BaseInterface {\n  protected getSecret(): string {\n    return `${this.opt.secret}${this.secret}`\n  }\n\n  private sock!: Socket\n  private readonly opt: TcpClientOptions\n  private ecdh = crypto.createECDH('prime256v1')\n  private secret = ''\n  private buf = Buffer.alloc(0)\n  private pending: Record<string, Pending<unknown>> = {}\n  private mClosed = false\n  private rTimer: NodeJS.Timeout | null = null\n  private connected = createDefer<boolean>()\n  private closed = true\n\n  constructor(opt: TcpClientOptions) {\n    super()\n    this.opt = opt\n  }\n\n  // ---------- socket lifecycle ----------\n  private spawn() {\n    this.sock = new Socket()\n    this.buf = Buffer.alloc(0)\n\n    this.sock.on('error', (err) => this.emit('error', err))\n    this.sock.on('close', () => this.onClose())\n    this.sock.once('connect', () => this.sendHandshake())\n    this.sock.on('data', (chunk) => this.onData(chunk))\n  }\n\n  private sendHandshake() {\n    this.ecdh.generateKeys()\n    const init: HandshakeInitialBody = { pub: this.ecdh.getPublicKey('hex'), name: this.opt.name }\n    this.sock.write(JSON.stringify(init))\n  }\n\n  // ---------- framing ----------\n  private onData(chunk: Buffer) {\n    if (!this.secret) return this.onHandshake(chunk)\n\n    this.buf = Buffer.concat([this.buf, chunk])\n    while (this.buf.length >= 4) {\n      const len = this.buf.readUInt32BE(0)\n      if (this.buf.length < 4 + len) break\n      const cipher = this.buf.subarray(4, 4 + len).toString('utf8')\n      this.buf = this.buf.subarray(4 + len)\n      if (this.closed) return\n      this.onMessage(cipher)\n    }\n  }\n\n  private onHandshake(chunk: Buffer) {\n    const str = chunk.toString().trimEnd()\n    let resp: HandshakeInitialBody\n    try {\n      resp = JSON.parse(str)\n    } catch {\n      this.sock.destroy()\n      return\n    }\n\n    const shared = this.ecdh.computeSecret(Buffer.from(resp.pub, 'hex'))\n    this.secret = crypto\n      .createHmac('sha256', this.opt.secret || '')\n      .update(shared)\n      .digest('hex')\n    this.connected.resolve(true)\n    this.emit('connect')\n  }\n\n  private onMessage(raw: string) {\n    let res: ResponseBody<unknown>\n    try {\n      res = this.decrypt<ResponseBody>(raw)\n    } catch {\n      return\n    }\n\n    const rec = this.pending[res.uuid]\n    if (!rec) return\n\n    if (res.error) {\n      rec.defer.reject(new Error(res.error))\n    } else {\n      rec.defer.resolve(res.body)\n    }\n    delete this.pending[res.uuid]\n  }\n\n  // ---------- public API ----------\n  public connect(): Promise<boolean> {\n    if (!this.closed) return this.connected\n    this.closed = false\n    this.mClosed = false\n    this.connected = createDefer<boolean>()\n    this.spawn()\n    this.sock.connect(this.opt.port, this.opt.host)\n    return this.connected\n  }\n\n  private onClose() {\n    this.closed = true\n    this.secret = ''\n    this.emit('close')\n\n    if (this.mClosed || !this.opt.autoReconnect) return\n\n    if (this.rTimer) return // already waiting\n    this.rTimer = setTimeout(() => {\n      this.rTimer = null\n      this.spawn()\n    }, this.opt.timeoutReconnect)\n  }\n\n  public close() {\n    this.mClosed = true\n    if (this.rTimer) {\n      clearTimeout(this.rTimer)\n      this.rTimer = null\n    }\n    if (this.sock) this.sock.destroy()\n    this.closed = true\n  }\n\n  public async send<Res = unknown, Req = unknown>(rout = '', body = {} as Req): Promise<Res> {\n    // если сокет закрыт (сервер упал/рестарт), переподключаемся принудительно\n    if (this.closed && !this.mClosed) {\n      await this.connect()\n    }\n\n    if (Object.keys(this.pending).length >= (this.opt.maxPending ?? 500)) {\n      throw new Error('Too many pending requests')\n    }\n\n    const uuid = crypto.randomUUID()\n    const packet: RequestBody<Req> = { uuid, rout, body }\n    const cipher = this.encrypt(JSON.stringify(packet))\n\n    const defer = createDefer<Res>()\n    this.pending[uuid] = { ts: Date.now(), defer: defer as unknown as Pending<unknown>['defer'] }\n\n    const buf = Buffer.from(cipher, 'utf8')\n    const frame = Buffer.allocUnsafe(4 + buf.length)\n    frame.writeUInt32BE(buf.length, 0)\n    buf.copy(frame, 4)\n\n    this.sock.write(frame)\n\n    return defer\n  }\n}\n"]}