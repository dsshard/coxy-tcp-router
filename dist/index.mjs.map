{"version":3,"sources":["../src/utils/encryptor.ts","../src/interface.ts","../src/utils/defer.ts","../src/utils/pipeline.ts","../src/server.ts","../src/utils/check-connection.ts","../src/client.ts"],"names":["ALG","IV_LEN","TAG_LEN","toKey","hex","crypto","encrypt","data","keyHex","key","iv","cipher","enc","tag","decrypt","payload","raw","decipher","BaseInterface","EventEmitter","sock","createDefer","resolve","reject","promise","_resolve","_reject","Pipeline","mw","stack","m","ctx","i","runner","idx","fn","TcpServer","o","createServer","s","cb","defer","ip","shared","ecdh","first","msg","init","chunk","len","req","route","pipe","res","body","e","out","buf","frame","r","p","checkInternet","socket","connect","TcpClient","opt","Socket","err","str","resp","rec","status","uuid","rout","packet"],"mappings":"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","file":"index.mjs","sourcesContent":["import crypto from 'node:crypto'\nconst ALG = 'aes-256-gcm'\nconst IV_LEN = 12\nconst TAG_LEN = 16\n\nfunction toKey(hex: string) {\n  return crypto.createHash('sha256').update(hex).digest()\n}\n\nexport function encrypt(data: string, keyHex: string): string {\n  const key = toKey(keyHex)\n  const iv = crypto.randomBytes(IV_LEN)\n  const cipher = crypto.createCipheriv(ALG, key, iv)\n  const enc = Buffer.concat([cipher.update(data, 'utf8'), cipher.final()])\n  const tag = cipher.getAuthTag()\n  return Buffer.concat([iv, enc, tag]).toString('base64')\n}\nexport function decrypt(payload: string, keyHex: string): string {\n  const raw = Buffer.from(payload, 'base64')\n  const key = toKey(keyHex)\n  const iv = raw.subarray(0, IV_LEN)\n  const tag = raw.subarray(raw.length - TAG_LEN)\n  const enc = raw.subarray(IV_LEN, raw.length - TAG_LEN)\n  const decipher = crypto.createDecipheriv(ALG, key, iv)\n  decipher.setAuthTag(tag)\n  return Buffer.concat([decipher.update(enc), decipher.final()]).toString('utf8')\n}\n","import EventEmitter from 'node:events'\n\nimport { decrypt, encrypt } from './utils/encryptor'\n\nexport abstract class BaseInterface extends EventEmitter {\n  protected abstract getSecret(sock?: unknown): string\n  protected encrypt(data: string, sock?: unknown) {\n    if (!this.getSecret(sock)) {\n      return data\n    }\n    return encrypt(data, this.getSecret(sock))\n  }\n\n  protected decrypt<T = unknown>(payload: string, sock?: unknown): T {\n    if (!this.getSecret(sock)) {\n      return JSON.parse(payload)\n    }\n    return JSON.parse(decrypt(payload, this.getSecret(sock))) as T\n  }\n}\n","export function createDefer<T>() {\n  let resolve!: (value: T | PromiseLike<T>) => void\n  let reject!: (reason?: unknown) => void\n\n  const promise = new Promise<T>((_resolve, _reject) => {\n    resolve = _resolve\n    reject = _reject\n  })\n\n  return Object.assign(promise, { resolve, reject })\n}\n","export type Next = () => Promise<void> | void\nexport interface Context<TReq, TRes> {\n  request: TReq\n  rout: string\n  body?: TRes\n}\n\nexport type Middleware<T> = (ctx: T, next: Next) => Promise<void> | void\nexport interface Pipeline<TC, TR> {\n  push: (...mw: Middleware<TC>[]) => void\n  execute: (ctx: TC) => Promise<{ body: TR }>\n}\nexport function Pipeline<TC, TR>(...mw: Middleware<TC>[]): Pipeline<TC, TR> {\n  const stack: Middleware<TC>[] = [...mw]\n  const push = (...m: Middleware<TC>[]) => stack.push(...m)\n  const execute = async (ctx: TC) => {\n    let i = -1\n    const runner = async (idx: number): Promise<void> => {\n      if (idx === i) throw new Error('next() called multiple times')\n      i = idx\n      const fn = stack[idx]\n      if (fn) await fn(ctx, () => runner(idx + 1))\n    }\n    await runner(0)\n    // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n    if ((ctx as any).body === undefined) throw new Error('Pipeline did not set ctx.body')\n    // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n    return { body: (ctx as any).body as TR }\n  }\n  return { push, execute }\n}\n","import crypto from 'node:crypto'\nimport { type Server, type Socket, createServer } from 'node:net'\n\nimport { BaseInterface } from './interface'\nimport { createDefer } from './utils/defer'\nimport { type Context, type Middleware, Pipeline } from './utils/pipeline'\n\nexport interface TcpRouterOptions {\n  port: number\n  host?: string\n  secret?: string\n  whitelist?: readonly string[]\n  maxConnections?: number\n}\nexport interface HandshakeInitialBody {\n  pub: string\n  name?: string\n}\nexport interface RequestBody<T = unknown> {\n  uuid: string\n  body: T\n  rout: string\n}\nexport interface ResponseBody<T = unknown> {\n  uuid: string\n  body?: T\n  error?: string\n}\n\ndeclare module 'net' {\n  interface Socket {\n    secret?: string\n    clientName?: string\n    _buf?: Buffer\n  }\n}\n\ntype AnyPipe = Pipeline<Context<unknown, unknown>, unknown>\n\nexport class TcpServer extends BaseInterface {\n  private readonly server: Server\n  private readonly opts: TcpRouterOptions\n  private readonly routers = new Map<string, AnyPipe>()\n  private readonly active = new Set<Socket>()\n\n  constructor(o: TcpRouterOptions) {\n    super()\n    this.opts = o\n    this.server = createServer((s) => this.handleSocket(s))\n  }\n\n  listen(cb?: () => void) {\n    const defer = createDefer<void>()\n    this.server.listen(this.opts.port, this.opts.host, () => {\n      this.emit('listening')\n      defer.resolve()\n      if (cb) cb()\n    })\n\n    return defer\n  }\n\n  protected getSecret(s?: Socket) {\n    return `${this.opts.secret}${s?.secret ?? ''}`\n  }\n\n  // ---------------- socket lifecycle ----------------\n  private handleSocket(s: Socket) {\n    const ip = (s.remoteAddress ?? '').replace(/^::ffff:/, '')\n    if (this.opts.whitelist && !this.opts.whitelist.includes(ip)) {\n      this.emit('error:whitelist', s)\n      return s.destroy()\n    }\n    if (this.opts.maxConnections && this.active.size >= this.opts.maxConnections) {\n      this.emit('error:maxConnections', s)\n      return s.destroy()\n    }\n\n    this.active.add(s)\n    s.setKeepAlive(true)\n    s._buf = Buffer.alloc(0)\n    s.on('close', () => {\n      this.active.delete(s)\n      this.emit('close', s)\n      s.removeAllListeners()\n    })\n    this.handshake(s)\n  }\n\n  /** Gracefully stop listening and destroy all active sockets */\n  public close() {\n    const defer = createDefer<void>()\n    this.server.once('close', () => {\n      setTimeout(defer.resolve)\n    })\n    this.server.close()\n\n    for (const sock of this.active) {\n      sock.destroy()\n    }\n    return defer\n  }\n\n  private deriveKey(shared: Buffer) {\n    return crypto\n      .createHmac('sha256', this.opts.secret || '')\n      .update(shared)\n      .digest('hex')\n  }\n\n  // ---------------- handshake ----------------\n  private handshake(s: Socket) {\n    const ecdh = crypto.createECDH('prime256v1')\n    ecdh.generateKeys()\n    const first = (raw: Buffer) => {\n      s.off('data', first)\n      const msg = raw.toString().trimEnd()\n      let init: HandshakeInitialBody\n      try {\n        init = JSON.parse(msg)\n      } catch {\n        return s.destroy()\n      }\n      const shared = ecdh.computeSecret(Buffer.from(init.pub, 'hex'))\n      s.secret = this.deriveKey(shared)\n      s.clientName = init.name\n      s.write(`${JSON.stringify({ pub: ecdh.getPublicKey('hex') })}\\n`)\n      this.emit('connect', s, init.name)\n      s.on('data', (chunk) => this.readFrames(s, chunk))\n    }\n    s.on('data', first)\n  }\n\n  // ---------------- length‑prefix framed stream ----------------\n  private readFrames(s: Socket, chunk: Buffer) {\n    // biome-ignore lint/style/noNonNullAssertion: <explanation>\n    s._buf = Buffer.concat([s._buf!, chunk])\n    while (s._buf.length >= 4) {\n      const len = s._buf.readUInt32BE(0)\n      if (s._buf.length < 4 + len) break\n      const payload = s._buf.subarray(4, 4 + len).toString('utf8')\n      s._buf = s._buf.subarray(4 + len)\n      void this.handleData(payload, s)\n    }\n  }\n\n  private async handleData<Q = unknown, S = unknown>(cipher: string, s: Socket) {\n    let req: RequestBody<Q>\n    try {\n      req = this.decrypt<RequestBody<Q>>(cipher, s)\n    } catch {\n      return\n    }\n    const route = req.rout?.toLowerCase()\n    const pipe = this.routers.get(route) as Pipeline<Context<Q, S>, S> | undefined\n\n    const res: ResponseBody<S> = { uuid: req.uuid }\n    try {\n      if (!pipe) throw new Error(`Route ${route} not found`)\n      const { body } = await pipe.execute({ request: req.body, rout: route })\n      res.body = body\n    } catch (e) {\n      res.error = (e as Error).message\n    }\n\n    const out = this.encrypt(JSON.stringify(res), s)\n    const buf = Buffer.from(out, 'utf8')\n    const frame = Buffer.allocUnsafe(4 + buf.length)\n    frame.writeUInt32BE(buf.length, 0)\n    buf.copy(frame, 4)\n    s.write(frame)\n  }\n\n  // ------------- public -------------\n  public use<Q = unknown, S = unknown>(r: string, ...mw: Middleware<Context<Q, S>>[]) {\n    const p = Pipeline<Context<Q, S>, S>()\n    p.push(...mw)\n    this.routers.set(r.trim().toLowerCase(), p as AnyPipe)\n  }\n}\n","import { connect } from 'node:net'\n\nexport function checkInternet(): Promise<boolean> {\n  return new Promise((resolve) => {\n    const socket = connect({ host: '1.1.1.1', port: 53, timeout: 3000 }, () => {\n      socket.destroy()\n      resolve(true)\n    })\n\n    socket\n      .on('connect', () => {\n        socket.destroy()\n        resolve(true)\n      })\n      .on('error', () => {\n        socket.destroy()\n        resolve(false)\n      })\n      .on('timeout', () => {\n        socket.destroy()\n        resolve(false)\n      })\n  })\n}\n","import crypto from 'node:crypto'\nimport { Socket } from 'node:net'\n\nimport { BaseInterface } from './interface'\nimport type { HandshakeInitialBody, RequestBody, ResponseBody } from './server'\nimport { checkInternet } from './utils/check-connection'\nimport { createDefer } from './utils/defer'\n\nexport interface TcpClientOptions {\n  port: number\n  host?: string\n  secret?: string\n  name?: string\n  autoReconnect?: boolean\n  timeoutReconnect?: number\n  keepAlive?: boolean\n}\n\ntype Pending<T> = { ts: number; defer: ReturnType<typeof createDefer<T>> }\n\nexport class TcpClient extends BaseInterface {\n  protected getSecret(): string {\n    return `${this.opt.secret}${this.secret}`\n  }\n\n  public sock!: Socket\n  private readonly opt: TcpClientOptions\n  private ecdh = crypto.createECDH('prime256v1')\n  private secret = ''\n  private buf = Buffer.alloc(0)\n  public pending: Record<string, Pending<unknown>> = {}\n  private mClosed = false\n  private rTimer: NodeJS.Timeout | null = null\n  private iTimer: NodeJS.Timeout | null = null\n  private connected = createDefer<boolean>()\n  private closed = true\n\n  constructor(opt: TcpClientOptions) {\n    super()\n    this.opt = opt\n  }\n\n  // ---------- socket lifecycle ----------\n  private spawn() {\n    this.sock = new Socket()\n    this.buf = Buffer.alloc(0)\n\n    this.sock.on('error', (err: Error & { code: string }) => {\n      if (err.code === 'ECONNRESET') {\n        this.onClose()\n        return\n      }\n      this.emit('error', err)\n    })\n    this.sock.on('close', () => this.onClose())\n    this.sock.once('connect', () => this.sendHandshake())\n    this.sock.on('data', (chunk) => this.onData(chunk))\n  }\n\n  private sendHandshake() {\n    this.ecdh.generateKeys()\n    const init: HandshakeInitialBody = { pub: this.ecdh.getPublicKey('hex'), name: this.opt.name }\n    this.sock.write(JSON.stringify(init))\n  }\n\n  // ---------- framing ----------\n  private onData(chunk: Buffer) {\n    if (!this.secret) return this.onHandshake(chunk)\n\n    this.buf = Buffer.concat([this.buf, chunk])\n    while (this.buf.length >= 4) {\n      const len = this.buf.readUInt32BE(0)\n      if (this.buf.length < 4 + len) break\n      const cipher = this.buf.subarray(4, 4 + len).toString('utf8')\n      this.buf = this.buf.subarray(4 + len)\n      if (this.closed) return\n      this.onMessage(cipher)\n    }\n  }\n\n  private onHandshake(chunk: Buffer) {\n    const str = chunk.toString().trimEnd()\n    let resp: HandshakeInitialBody\n    try {\n      resp = JSON.parse(str)\n    } catch {\n      this.sock.destroy()\n      return\n    }\n\n    const shared = this.ecdh.computeSecret(Buffer.from(resp.pub, 'hex'))\n    this.secret = crypto\n      .createHmac('sha256', this.opt.secret || '')\n      .update(shared)\n      .digest('hex')\n    this.connected.resolve(true)\n    this.emit('connect')\n  }\n\n  private onMessage(raw: string) {\n    let res: ResponseBody<unknown>\n    try {\n      res = this.decrypt<ResponseBody>(raw)\n    } catch {\n      return\n    }\n\n    const rec = this.pending[res.uuid]\n    if (!rec) return\n\n    if (res.error) {\n      rec.defer.reject(new Error(res.error))\n    } else {\n      rec.defer.resolve(res.body)\n    }\n    delete this.pending[res.uuid]\n  }\n\n  // ---------- public API ----------\n  public async connect(): Promise<boolean> {\n    if (!this.closed) return this.connected\n    this.closed = false\n    this.mClosed = false\n    this.connected = createDefer<boolean>()\n\n    const status = await checkInternet()\n    if (!status) {\n      this.onClose()\n      return\n    }\n\n    this.spawn()\n    this.sock.connect(this.opt.port, this.opt.host)\n    await this.connected\n    if (this.opt.keepAlive) {\n      this.sock.setKeepAlive(true, 1000) // 10 секунд\n    }\n\n    clearInterval(this.iTimer)\n    this.iTimer = setInterval(() => {\n      checkInternet().then((status) => {\n        this.emit('internet', status)\n        if (!status) {\n          this.onClose()\n        }\n      })\n    }, 5000)\n    return true\n  }\n\n  private onClose() {\n    clearInterval(this.iTimer)\n    this.closed = true\n    this.secret = ''\n\n    for (const uuid of Object.keys(this.pending)) {\n      const rec = this.pending[uuid]\n      rec.defer.reject(new Error('Client closed'))\n      delete this.pending[uuid]\n    }\n\n    if (this.rTimer) return // already waiting\n    if (this.mClosed || !this.opt.autoReconnect) return\n    this.emit('close')\n\n    this.rTimer = setTimeout(() => {\n      this.rTimer = null\n      void this.connect()\n    }, this.opt.timeoutReconnect)\n  }\n\n  public close() {\n    clearInterval(this.iTimer)\n    this.mClosed = true\n    if (this.rTimer) {\n      clearTimeout(this.rTimer)\n      this.rTimer = null\n    }\n\n    if (this.sock) {\n      this.sock.removeAllListeners()\n      this.sock.destroy()\n    }\n    this.closed = true\n  }\n\n  public async send<Res = unknown, Req = unknown>(rout = '', body = {} as Req): Promise<Res> {\n    // если сокет закрыт (сервер упал/рестарт), переподключаемся принудительно\n    if (this.closed && !this.mClosed) {\n      await this.connect()\n    }\n\n    const uuid = crypto.randomUUID()\n    const packet: RequestBody<Req> = { uuid, rout, body }\n    const cipher = this.encrypt(JSON.stringify(packet))\n\n    const defer = createDefer<Res>()\n    this.pending[uuid] = { ts: Date.now(), defer: defer as unknown as Pending<unknown>['defer'] }\n\n    const buf = Buffer.from(cipher, 'utf8')\n    const frame = Buffer.allocUnsafe(4 + buf.length)\n    frame.writeUInt32BE(buf.length, 0)\n    buf.copy(frame, 4)\n\n    this.sock.write(frame)\n\n    return defer\n  }\n}\n"]}